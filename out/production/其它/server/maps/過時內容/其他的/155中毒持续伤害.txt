            duration += from.getStat().dotTime * 1000; //有些被动技能增加 延长时间
            //System.out.println("中毒时间 - 被动加成: " + from.getStat().dotTime * 1000 + " 最终时间: " + duration);
            if (stat != MonsterStatus.POISON && duration >= 4000) { //如果大于60秒 时间设置为 10秒中毒持续时间
                duration = 4000;
            }
            long aniTime = duration;
            status.setCancelTask(aniTime);
            if (poison && getHp() > 1) {
                if (status.getWeakChr() != null || !status.isCannelPoison()) {
                    return;
                }
                status.setDotTime(duration); //设置中毒的持续时间
                int poisonDot = from.getStat().dot;
                int damageIncrease = from.getStat().getDamageIncrease(eff.getSourceId());
                if (damageIncrease > eff.getDOT()) {
                    poisonDot += damageIncrease;
                } else {
                    poisonDot += eff.getDOT();
                }
                if (from.isAdmin()) {
                    from.dropMessage(6, "[怪物DEBUFF] 中毒 技能ID: " + eff.getSourceId() + " 持续伤害:" + eff.getDOT() + " 被动:" + from.getStat().dot + " 被动加成:" + damageIncrease + " 最终加成:" + poisonDot);
                }
                status.setValue(status.getStati(), (int) (poisonDot * from.getStat().getCurrentMaxBaseDamage() / 100.0));
                int poisonDamage = (int) (aniTime / 1000 * status.getX() / 2);
                if (from.isAdmin()) {
                    from.dropMessage(6, "[怪物DEBUFF] 中毒伤害 中毒伤害: " + poisonDamage + " 持续时间: " + aniTime + " 持续伤害: " + status.getX());
                }
                status.setPoisonSchedule(poisonDamage, from);





        if (stat == MonsterStatus.POISON || stat == MonsterStatus.BURN) {
            poisonsLock.writeLock().lock();
            try {
                poisons.add(status);
                status.doPoisonTask(this);//持續掉血
                if (con != null) {



搜索：

    public final void cancelPoisonSchedule(MapleMonster mm) {
	mm.doPoison(this, weakChr);
	this.poisonSchedule = 0;
	this.weakChr = null;
    }

替换：


    public final void cancelPoisonSchedule(MapleMonster mm) {
	mm.doPoison(this, weakChr);
	this.poisonSchedule = 0;
	this.weakChr = null;
    }

    public WeakReference<MapleCharacter> getWeakChr() {
        return weakChr;
    }

    public boolean isCannelPoison() {
        return cannelPoison;
    }

    public void setDotTime(long duration) {
        this.dotTime = duration;
    }

    public void doPoisonTask(MapleMonster monster) {
        if (cannelPoison) {
            doPoisonSchedu = Timer.BuffTimer.getInstance().register(() -> {
                if (monster != null && monster.isAlive() && weakChr != null && weakChr.get() != null && poisonSchedule != 0) {
                    cannelPoison = false;
                    monster.doPoison(this, weakChr);
                } else if (doPoisonSchedu != null) {
                    doPoisonSchedu.cancel(true);
                    doPoisonSchedu = null;
                }
            }, 1000, 1000);
        }
    }


搜索：

    private boolean reflect = false;
    private long cancelTime = 0;

替换：

    private boolean reflect = false;
    private long cancelTime = 0, dotTime = 0;;
    private boolean cannelPoison = true;
    private ScheduledFuture doPoisonSchedu;



页首

import java.util.concurrent.ScheduledFuture;
import server.Timer;
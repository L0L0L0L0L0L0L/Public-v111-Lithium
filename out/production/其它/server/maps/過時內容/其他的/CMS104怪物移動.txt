搜索：

    public static final void MoveMonster(final LittleEndianAccessor slea, final MapleClient c, final MapleCharacter chr) {
        if (chr == null || chr.getMap() == null) {
            return; //?
        }
        final int oid = slea.readInt();
        final MapleMonster monster = chr.getMap().getMonsterByOid(oid);

        if (monster == null) { // movin something which is not a monster
            return;
        }
        if (monster.getLinkCID() > 0) {
            return;
        }
        final short moveid = slea.readShort();
        final boolean useSkill = slea.readByte() > 0;
        final byte skill = slea.readByte();
        final int unk = slea.readInt();
        int realskill = 0;
        int level = 0;

        if (useSkill) {// && (skill == -1 || skill == 0)) {
            final byte size = monster.getNoSkills();
            boolean used = false;

            if (size > 0) {
                final Pair<Integer, Integer> skillToUse = monster.getSkills().get((byte) Randomizer.nextInt(size));
                realskill = skillToUse.getLeft();
                level = skillToUse.getRight();
                // Skill ID and Level
                final MobSkill mobSkill = MobSkillFactory.getMobSkill(realskill, level);

                if (mobSkill != null && !mobSkill.checkCurrentBuff(chr, monster)) {
                    final long now = System.currentTimeMillis();
                    final long ls = monster.getLastSkillUsed(realskill);

                    if (ls == 0 || (((now - ls) > mobSkill.getCoolTime()) && !mobSkill.onlyOnce())) {
                        monster.setLastSkillUsed(realskill, now, mobSkill.getCoolTime());

                        final int reqHp = (int) (((float) monster.getHp() / monster.getMobMaxHp()) * 100); // In case this monster have 2.1b and above HP
                        if (reqHp <= mobSkill.getHP()) {
                            used = true;
                            mobSkill.applyEffect(chr, monster, true);
                        }
                    }
                }
            }
            if (!used) {
                realskill = 0;
                level = 0;
            }
        }
        final List<Pair<Integer, Integer>> unk3 = new ArrayList<Pair<Integer, Integer>>();
        final byte size1 = slea.readByte();
        for (int i = 0; i < size1; i++) {
            unk3.add(new Pair<Integer, Integer>(Integer.valueOf(slea.readShort()), Integer.valueOf(slea.readShort())));
        }
        final List<Integer> unk2 = new ArrayList<Integer>();
        final byte size = slea.readByte();
        for (int i = 0; i < size; i++) {
            unk2.add(Integer.valueOf(slea.readShort()));
        }
        slea.skip(1);
        slea.skip(4); // sometimes 0, 1
        slea.skip(4); // CC DD FF 00  same for all mobs
        slea.skip(4); // CC DD FF 00  same for all mobs
        slea.skip(4); // 9D E1 87 48  same for all mobs
        slea.skip(1); // 1?
        slea.skip(4); // original pos
        slea.skip(4); // all 0
        final Point startPos = monster.getPosition();
        List<LifeMovementFragment> res = null;
        try {
            res = MovementParse.parseMovement(slea, 2);
        } catch (ArrayIndexOutOfBoundsException e) {
            FileoutputUtil.outputFileError(FileoutputUtil.Movement_Log, e);
            FileoutputUtil.log(FileoutputUtil.Movement_Log, "MOBID " + monster.getId() + ", AIOBE Type2:\n" + slea.toString(true));
            return;
        }
        if (res != null && chr != null && res.size() > 0) {
            final MapleMap map = chr.getMap();
            for (final LifeMovementFragment move : res) {
                if (move instanceof AbsoluteLifeMovement) {
                    final Point endPos = ((LifeMovement) move).getPosition();
                    if (endPos.x < (map.getLeft() - 250) || endPos.y < (map.getTop() - 250) || endPos.x > (map.getRight() + 250) || endPos.y > (map.getBottom() + 250)) { //experimental
                        chr.getCheatTracker().checkMoveMonster(endPos);
                        return;
                    }
                }
            }
            c.getSession().write(MobPacket.moveMonsterResponse(monster.getObjectId(), moveid, monster.getMp(), monster.isControllerHasAggro(), realskill, level));
            if (slea.available() != 35/*slea.available() < 11 || slea.available() > 35*/) {
                // [byte][int-pos][int-pos][5-same for all mobs][21]
                //70 F4 81 CE 14 00 00 00 00 00 00 00 CB A2 03 00 05 00 00 00 02
                FileoutputUtil.log(FileoutputUtil.PacketEx_Log, "slea.available != 35 (movement parsing error)\n" + slea.toString(true));
                //c.getSession().close();
                return;
            }
            MovementParse.updatePosition(res, monster, -1);
            final Point endPos = monster.getTruePosition();
            map.moveMonster(monster, endPos);
            map.broadcastMessage(chr, MobPacket.moveMonster(useSkill, skill, unk, monster.getObjectId(), startPos, res, unk2, unk3), endPos);
            chr.getCheatTracker().checkMoveMonster(endPos);
        }
    }


替换：

    public static void MoveMonster(LittleEndianAccessor slea, MapleClient c, MapleCharacter chr) {
        if ((chr == null) || (chr.getMap() == null)) {
            return;
        }
        int oid = slea.readInt();
        MapleMonster monster = chr.getMap().getMonsterByOid(oid);
        if (monster == null) {
            return;
        }
        if (monster.getLinkCID() > 0) {
            return;
        }

        short moveid = slea.readShort();
        boolean useSkill = (slea.readByte() & 0xFF) > 0;
        byte action = slea.readByte();
        int skillId = slea.readByte() & 0xFF;
        int skillLevel = slea.readByte();
        short delay = slea.readShort();

        int realskill = 0;
        int level = 0;
        if (useSkill) {
            byte size = monster.getNoSkills();
            boolean used = false;
            if (size > 0) {
                Pair skillToUse = (Pair) monster.getSkills().get((byte) Randomizer.nextInt(size));
                realskill = ((Integer) skillToUse.getLeft()).intValue();
                level = ((Integer) skillToUse.getRight()).intValue();

                MobSkill mobSkill = MobSkillFactory.getMobSkill(realskill, level);
                if ((mobSkill != null) && (!mobSkill.checkCurrentBuff(chr, monster))) {
                    long now = System.currentTimeMillis();
                    long ls = monster.getLastSkillUsed(realskill);
                    if ((ls == 0L) || ((now - ls > mobSkill.getCoolTime()) && (!mobSkill.onlyOnce()))) {
                        monster.setLastSkillUsed(realskill, now, mobSkill.getCoolTime());
                        int reqHp = (int) ((float) monster.getHp() / (float) monster.getMobMaxHp() * 100.0F);
                        if (reqHp <= mobSkill.getHP()) {
                            used = true;
                            mobSkill.applyEffect(chr, monster, true);
                        }
                    }
                }
            }
            if (!used) {
                realskill = 0;
                level = 0;
            }

        }

        byte aa = slea.readByte();
        if (aa > 0) {
            for (int i = 0; i < aa; i++) {
                slea.skip(4);
            }
        }
        byte gg = slea.readByte();

        if (gg > 0) {
            for (int i = 0; i < gg; i++) {
                slea.skip(2);
            }
        }
        slea.skip(1);
        boolean skipped = (slea.readInt() != 0) && (gg > 0);
        slea.skip(8);
        slea.skip(5);
        slea.skip(4);
        slea.skip(4);
        if ((monster.getId() == 9300281) && (skipped)) {
            if (slea.readByte() > 10) {
                slea.skip(8);
            } else {
                slea.seek(slea.getPosition() - 1L);
            }
        }
        Point startPos = monster.getPosition();
        List<LifeMovementFragment> res;
        try {
            res = MovementParse.parseMovement(slea, 2);
        } catch (ArrayIndexOutOfBoundsException e) {
            FileoutputUtil.outputFileError("log\\Movement.log", e);
            FileoutputUtil.log("log\\Movement.log", "怪物ID " + monster.getId() + ", AIOBE Type2:\r\n" + slea.toString(true));
            return;
        }
        if ((res != null) && (chr != null) && (res.size() > 0)) {
            MapleMap map = chr.getMap();
            for (LifeMovementFragment move : res) {
                if ((move instanceof AbsoluteLifeMovement)) {
                    Point endPos = ((LifeMovement) move).getPosition();
                    if ((endPos.x < map.getLeft() - 250) || (endPos.y < map.getTop() - 250) || (endPos.x > map.getRight() + 250) || (endPos.y > map.getBottom() + 250)) {
                        chr.getCheatTracker().checkMoveMonster(endPos);
                        return;
                    }
                }
            }
            slea.skip(1);
            slea.skip(4);
            slea.skip(4);
            c.getSession().write(MobPacket.moveMonsterResponse(monster.getObjectId(), moveid, monster.getMp(), monster.isControllerHasAggro(), realskill, level));
            if ((slea.available() < 9L) || (slea.available() > 30L)) {
                FileoutputUtil.log("log\\Packet_Except.log", "slea.available != 30 (movement parsing error)\n" + slea.toString(true));

                return;
            }
            MovementParse.updatePosition(res, monster, -1);
            Point endPos = monster.getTruePosition();
            map.moveMonster(monster, endPos);
            map.broadcastMessage(chr, MobPacket.moveMonster(useSkill, action, skillId, skillLevel, delay, monster.getObjectId(), startPos, res), endPos);
            chr.getCheatTracker().checkMoveMonster(endPos);
        }
    }



搜索：

    public static byte[] moveMonster(boolean useskill, int skill, int unk, int oid, Point startPos, List<LifeMovementFragment> moves) {
        return moveMonster(useskill, skill, unk, oid, startPos, moves, null, null);
    }

    public static byte[] moveMonster(boolean useskill, int skill, int unk, int oid, Point startPos, List<LifeMovementFragment> moves, final List<Integer> unk2, final List<Pair<Integer, Integer>> unk3) {
        MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();

        mplew.writeShort(SendPacketOpcode.MOVE_MONSTER.getValue());
        mplew.writeInt(oid);
        mplew.write(useskill ? 1 : 0);
        mplew.write(skill);
        mplew.writeInt(unk);
        mplew.write(unk3 == null ? 0 : unk3.size()); // For each, 2 short
        if (unk3 != null) {
            for (final Pair<Integer, Integer> i : unk3) {
                mplew.writeShort(i.left);
                mplew.writeShort(i.right);
            }
        }
        mplew.write(unk2 == null ? 0 : unk2.size()); // For each, 1 short
        if (unk2 != null) {
            for (final Integer i : unk2) {
                mplew.writeShort(i);
            }
        }
        mplew.writePos(startPos);
        mplew.writeShort(8);
        mplew.writeShort(1);
        PacketHelper.serializeMovementList(mplew, moves);

        return mplew.getPacket();
    }


替换：


    public static byte[] moveMonster(boolean useskill, int action, int skillId, int skillLevel, int delay, int oid, Point startPos, List<LifeMovementFragment> moves) {
        MaplePacketLittleEndianWriter mplew = new MaplePacketLittleEndianWriter();

        mplew.writeShort(SendPacketOpcode.MOVE_MONSTER.getValue());
        mplew.writeInt(oid);
        mplew.write(useskill ? 1 : 0);
        mplew.write(action);
        mplew.write(skillId);
        mplew.write(skillLevel);
        mplew.writeShort(delay);
        mplew.writeShort(0);
        mplew.writePos(startPos);
        mplew.writeInt(0);
        PacketHelper.serializeMovementList(mplew, moves);

        return mplew.getPacket();
    }


搜索：

                                    if (shouldAdd) { //walk up to the required range of the attack
                                        List<LifeMovementFragment> moves2 = new ArrayList<LifeMovementFragment>();
                                        maskedPos = new Point(battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().x + (startPos.x < battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().x ? -theAtk.getRange() : theAtk.getRange()), battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().y);
                                        alm = new AbsoluteLifeMovement(0, maskedPos, WALK_TIME, battlers[i].getMonster().getFacingDirection() + 2);
                                        alm.defaulted();
                                        moves2.add(alm); //separate for this movement only, as we must move THEN attack
                                        map.broadcastMessage(MobPacket.moveMonster(false, (byte) -1, 0, battlers[i].getMonster().getObjectId(), startPos, moves2));
                                    }


替换：

                                    if (shouldAdd) { //walk up to the required range of the attack
                                        List<LifeMovementFragment> moves2 = new ArrayList<LifeMovementFragment>();
                                        maskedPos = new Point(battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().x + (startPos.x < battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().x ? -theAtk.getRange() : theAtk.getRange()), battlers[i == 0 ? 1 : 0].getMonster().getTruePosition().y);
                                        alm = new AbsoluteLifeMovement(0, maskedPos, WALK_TIME, battlers[i].getMonster().getFacingDirection() + 2);
                                        alm.defaulted();
                                        moves2.add(alm); //separate for this movement only, as we must move THEN attack
                                        map.broadcastMessage(MobPacket.moveMonster(false, -1, 0, 0, 0, battlers[i].getMonster().getObjectId(), startPos, moves2));
                                    }



搜索：

                                final Point mPos = maskedPos;
                                if (mPos == null) {
                                    map.broadcastMessage(MobPacket.moveMonster(skillByte > 0, skillByte, 0, battlers[i].getMonster().getObjectId(), startPos, moves));
                                    moves.clear();
                                }

替换：

                                final Point mPos = maskedPos;
                                if (mPos == null) {
                                    map.broadcastMessage(MobPacket.moveMonster(skillByte > 0, skillByte, 0, 0, 0, battlers[i].getMonster().getObjectId(), startPos, moves));
                                    moves.clear();
                                }

搜索：

                                    public void run() {
                                        if (disposed || map == null || battlers[i == 1 ? 0 : 1] == null || battlers[i] == null) {
                                            return;
                                        }
                                        if (mPos != null) {
                                            map.broadcastMessage(MobPacket.moveMonster(skillByte > 0, skillByte, 0, battlers[i].getMonster().getObjectId(), mPos, moves));
                                            moves.clear();
                                        }

替换：

                                    public void run() {
                                        if (disposed || map == null || battlers[i == 1 ? 0 : 1] == null || battlers[i] == null) {
                                            return;
                                        }
                                        if (mPos != null) {
                                            map.broadcastMessage(MobPacket.moveMonster(skillByte > 0, skillByte, 0, 0, 0, battlers[i].getMonster().getObjectId(), mPos, moves));
                                            moves.clear();
                                        }


搜索：

                                            if (basedamage > 1) {
                                                final byte skillByte2 = (byte) (14 + battlers[i == 1 ? 0 : 1].getMonster().getFacingDirection());
                                                AbsoluteLifeMovement alm2 = new AbsoluteLifeMovement(0, battlers[i == 1 ? 0 : 1].getMonster().getPosition(), 0, battlers[i == 1 ? 0 : 1].getMonster().getStance());
                                                alm2.defaulted();
                                                moves.add(alm2); //"hit" face
                                                map.broadcastMessage(MobPacket.moveMonster(true, skillByte2, 0, battlers[i == 1 ? 0 : 1].getMonster().getObjectId(), battlers[i == 1 ? 0 : 1].getMonster().getTruePosition(), moves));
                                            }

替换：

                                            if (basedamage > 1) {
                                                final byte skillByte2 = (byte) (14 + battlers[i == 1 ? 0 : 1].getMonster().getFacingDirection());
                                                AbsoluteLifeMovement alm2 = new AbsoluteLifeMovement(0, battlers[i == 1 ? 0 : 1].getMonster().getPosition(), 0, battlers[i == 1 ? 0 : 1].getMonster().getStance());
                                                alm2.defaulted();
                                                moves.add(alm2); //"hit" face
                                                map.broadcastMessage(MobPacket.moveMonster(true, skillByte2, 0, 0, 0, battlers[1].getMonster().getObjectId(), battlers[1].getMonster().getTruePosition(), moves));
                                            }
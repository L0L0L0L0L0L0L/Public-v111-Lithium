搜索：

    public static int userLimit = 100;
    public static int maxCharacters = 6;


替換：

    public static int userLimit = 100;
    public static int maxCharacters = 6;
    public static boolean DEBUG = false;



下麵添加導入外部設置：

    DEBUG = Boolean.parseBoolean(ServerProperties.getProperty("net.sf.odinms.world.DEBUG", "false"));






搜索替換：

package handling.netty;

import client.MapleClient;
import constants.GameConstants;
import constants.ServerConstants;
import handling.SendPacketOpcode;
import handling.login.LoginServer;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToByteEncoder;
import java.util.concurrent.locks.Lock;
import tools.FileoutputUtil;
import tools.HexTool;
import tools.MapleAESOFB;
import tools.MapleCustomEncryption;
import tools.StringUtil;

public class MaplePacketEncoder extends MessageToByteEncoder<Object> {

    @Override
    protected void encode(ChannelHandlerContext chc, Object message, ByteBuf buffer) throws Exception {
        final MapleClient client = (MapleClient) chc.channel().attr(MapleClient.CLIENT_KEY).get();

        if (client != null) {
            final MapleAESOFB send_crypto = client.getSendCrypto();
            final byte[] inputInitialPacket = ((byte[]) message);
            byte[] input = inputInitialPacket;
            int pHeader = ((input[0]) & 0xFF) + (((input[1]) & 0xFF) << 8);

	    if (ServerConstants.DEBUG) {
	        int packetLen = inputInitialPacket.length;
	        String pHeaderStr = Integer.toHexString(pHeader).toUpperCase();
	        pHeaderStr = StringUtil.getLeftPaddedStr(pHeaderStr, '0', 4);
	        String op = nameOf(pHeader);
	        String Recv = "伺服端發送 " + op + " [" + pHeaderStr + "] (" + packetLen + ")\r\n";
	        if (packetLen <= 50000) {
	            //String RecvTo = Recv + HexTool.toString(inputInitialPacket) + "\r\n" + HexTool.toStringFromAscii(inputInitialPacket);//數據包解析
	            String RecvTo = Recv + HexTool.toString(inputInitialPacket);
	            System.out.println(RecvTo + "\r\n");
	        }
	    }
            final byte[] unencrypted = new byte[inputInitialPacket.length];
            System.arraycopy(inputInitialPacket, 0, unencrypted, 0, inputInitialPacket.length); // Copy the input > "unencrypted"
            final byte[] ret = new byte[unencrypted.length + 4]; // Create new bytes with length = "unencrypted" + 4

            final Lock mutex = client.getLock();
            mutex.lock();
            try {
                final byte[] header = send_crypto.getPacketHeader(unencrypted.length);
                MapleCustomEncryption.encryptData(unencrypted); // Encrypting Data
                send_crypto.crypt(unencrypted); // Crypt it with IV
                System.arraycopy(header, 0, ret, 0, 4); // Copy the header > "Ret", first 4 bytes
                System.arraycopy(unencrypted, 0, ret, 4, unencrypted.length); // Copy the unencrypted > "ret"

                buffer.writeBytes(ret);
            } finally {
                mutex.unlock();
            }
        } else { // no client object created yet, send unencrypted (hello)
            byte[] input = (byte[]) message;

            buffer.writeBytes(input);
        }
    }

    private String nameOf(int val) {
        for (SendPacketOpcode op : SendPacketOpcode.values()) {
          if (op.getValue() == val) {
            return op.name();
          }
        }
        return "UNKNOWN";
    }
}



搜索替換：

package handling.netty;

import client.MapleClient;
import constants.ServerConstants;
import handling.RecvPacketOpcode;
import handling.login.LoginServer;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageDecoder;
import io.netty.util.AttributeKey;
import java.util.Arrays;
import java.util.List;
import tools.FileoutputUtil;
import tools.HexTool;
import tools.MapleAESOFB;
import tools.MapleCustomEncryption;
import tools.data.input.GenericLittleEndianAccessor;

public class MaplePacketDecoder extends ByteToMessageDecoder {

    public static final AttributeKey<DecoderState> DECODER_STATE_KEY = AttributeKey.newInstance(MaplePacketDecoder.class.getName() + ".STATE");

    public static class DecoderState {

        public int packetlength = -1;
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> message) throws Exception {
        final DecoderState decoderState = ctx.channel().attr(DECODER_STATE_KEY).get();
        final MapleClient client = ctx.channel().attr(MapleClient.CLIENT_KEY).get();
         
        if (decoderState.packetlength == -1) {
            if (in.readableBytes() >= 4) {
                final int packetHeader = in.readInt();
                if (!client.getReceiveCrypto().checkPacket(packetHeader)) {
                     ctx.channel().disconnect();
                    return;
                }
                decoderState.packetlength = MapleAESOFB.getPacketLength(packetHeader);
            } else {
                return;
            }
        }
        if (in.readableBytes() >= decoderState.packetlength) {
            final byte decryptedPacket[] = new byte[decoderState.packetlength];
            in.readBytes(decryptedPacket);
            decoderState.packetlength = -1;

            client.getReceiveCrypto().crypt(decryptedPacket);
            MapleCustomEncryption.decryptData(decryptedPacket);
            message.add(decryptedPacket);
            int packetLen = decryptedPacket.length;
            short pHeader = new GenericLittleEndianAccessor(new tools.data.input.ByteArrayByteStream(decryptedPacket)).readShort();
	    if (ServerConstants.DEBUG) {
	        String pHeaderStr = Integer.toHexString(pHeader).toUpperCase();

	        String op = nameOf(pHeader);
                String tab = "";
                for (int i = 4; i > op.length() / 8; i--) {
                    tab += "\t";
                }
	        String Send = "用戶端發送 " + op + " [" + pHeaderStr + "] (" + packetLen + ")\r\n";
	        if (packetLen <= 6000) {
	          String SendTo = Send + HexTool.toString(decryptedPacket) + "\r\n" + HexTool.toStringFromAscii(decryptedPacket);
	            System.out.println(SendTo + "\r\n");
	          }
	      }
        }
    }

    public static String nameOf(short value) {
        for (RecvPacketOpcode header : RecvPacketOpcode.values()) {
            if (header.getValue() == value) {
                return header.name();
            }
        }
        return "UNKNOWN";
    }
}